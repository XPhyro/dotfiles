#!/usr/bin/env sh

clr() {
    printf "$2$1%s" "$NC"
}

clrl() {
    clr "$1\n" "$2"
}

#BLACK='\033[0;30m'
RED='\033[0;31m'
#GREEN='\033[0;32m'
#ORANGE='\033[0;33m'
#BLUE='\033[0;34m'
#PURPLE='\033[0;35m'
#CYAN='\033[0;36m'
#LGRAY='\033[0;37m'
#DGRAY='\033[1;30m'
LRED='\033[1;31m'
#LGREEN='\033[1;32m'
#YELLOW='\033[1;33m'
#LBLUE='\033[1;34m'
#LPURPLE='\033[1;35m'
#LCYAN='\033[1;36m'
#WHITE='\033[1;37m'
NC='\033[0m'

WS="    "
WSS="$WS$WS"
WSSS="$WSS$WS"

BASE="$HOME/.dotfiles"
BASEST="$HOME/.dotfiles-sensitive"
LIST="dotfiles.list"
LISTST="$BASEST/dotfiles-sensitive.list"

cd "$BASE" || { 
    printf "Could not cd to %s, exiting\n" "$BASE"
    exit 1
}

printf "Processing %s\n" "$LIST"

sort -V "$LIST" -o "$LIST"

files=""
locs=""
n=0

while read -r i
do
    files="$files$i "
    locs="$locs$( printf "%s" "$i" | sed -e 's/.*~\///' ) "
    n=$(( n + 1 ))
done < "$LIST"

[ "$files" ] || {
    printf "Nothing in %s, exiting\n" "$LIST"
    exit 0
}

printf "Moving files and directories\n"

for i in $( seq 1 "$n" )
do
    file="$( printf "%s" "$files" | awk -v "j=$i" '{print $j}' )"
    loc="$( printf "%s" "$locs" | awk -v "j=$i" '{print $j}' | expandpath )"

    locexists=""
    willonlylink=""
    
    printf "%sMoving %s to %s\n" "$WS" "$file" "$loc"

    grep -Fxq "$file" "$LISTST" && {
        clrl "${WSS}Source exists in $LISTST" "$RED"
        clrl "${WSS}Refusing to continue, exiting" "$RED"
        exit 1
    }

    file="$( expandpath "$file" )"

    [ -d "$loc" -o -f "$loc" ] && locexists=1

    if ! [ -d "$file" ] && ! [ -f "$file" ] && ! [ -L "$file" ] 
    then
        if ! [ "$locexists" ]
        then
            clrl "${WSS}Source file or directory does not exist, ignoring" "$RED"
        else
            clrl "${WSS}Source file does not exist, but the target does; linking" "$LRED"
            willonlylink=1
        fi
    elif [ -L "$file" ] && [ ! -e "$file" ]
    then
        clrl "${WSS}Source file exists, but is a broken symlink; fixing" "$LRED"

        target="$( readlink "$file" )"
        possibletarget=".$( printf "%s" "$target" | sed 's/^.*\.dotfiles\///' )"

        if [ -d "$possibletarget" ] || [ -f "$possibletarget" ]
        then
            rm "$file"
            willonlylink=1
        else
	    possibletarget=".$( printf "%s" "$target" )"

            if [ -d "$possibletarget" ] || [ -f "$possibletarget" ]
	    then
		rm "$file"
		willonlylink=1
	    else
                clrl "${WSSS}Could not fix symlink" "$RED"
                continue
	    fi
        fi
    fi

    [ "$willonlylink" ] && {
        ln -s "$BASE/$loc" "$file"
        continue
    }

    [ "$locexists" ] && { 
        printf "%sTarget file or directory exists, continuing\n" "$WSS"
        continue
    }

    [ "$loc" = "$( printf "%s" "$loc" | sed -e 's/\(.*\)\/.*$/\1 /' )" ] || mkdir -p "$( printf "%s" "$loc" | sed -e 's/\(.*\)\/.*$/\1 /' -e 's/.$//' )"
    mv "$file" "$loc"
    ln -s "$BASE/$loc" "$file"
done

printf "Creating .gitignore\n"

sed 's/~\///' "$LISTST" > .gitignore # just in case something sensitive ends up here
printf ".gitignore\n" >> .gitignore # names might also reveal information

printf "Committing changes\n"

git add .
git remote update
if [ "$( git status -uno -s )" ]
then
    git pull > /dev/null 2>&1
    git commit -m "#$(( $( git rev-list --all --count ) + 1 )): Auto commit by dotfilesbak"
    git push
else
    printf "Already up to date\n"
fi

printf "Removing .gitignore\n"

rm .gitignore
